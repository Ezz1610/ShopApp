
//
//  CategoriesProductsViewModel.swift
//  ShopApp
//
//  Created by mohamed ezz on 27/10/2025.
//

import Foundation
import SwiftUI
import SwiftData


import Foundation
import SwiftUI
import SwiftData

// MARK: - Product Filter Model
struct ProductFilter {
    var productTypes: Set<String> = []
    var optionSelections: [String: String] = [:]
    var maxPrice: Double? = nil
    var onlyInStock: Bool = false
    var onlyAccessories: Bool = false
}

@MainActor
final class CategoriesProductsViewModel: ObservableObject {
    private let dataHelper: SwiftDataHelper
    private let apiService = ApiServices()  // ðŸŸ¢ Ø±Ø¨Ø· Ø§Ù„Ù€ API Ù‡Ù†Ø§

    @Published var categories: [Category] = []
    @Published var allProducts: [ProductModel] = [] // Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
    @Published var products: [ProductModel] = []    // Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø©
    @Published var favorites: [ProductModel] = []

    @Published var selectedCategory: Category?
    @Published var filter = ProductFilter()
    @Published var isLoading = false
    @Published var errorMessage: String?
    @Published var searchText: String = ""

    static var shared: CategoriesProductsViewModel!

    private init(context: ModelContext) {
        self.dataHelper = SwiftDataHelper.shared(context: context)
    }

    static func initializeSingleton(context: ModelContext) {
        guard shared == nil else { return }
        shared = CategoriesProductsViewModel(context: context)
    }

    // MARK: - Filtered Products
    var filteredProducts: [ProductModel] {
        products.filter { product in
            if !searchText.isEmpty {
                let keyword = searchText.lowercased()
                guard product.title.lowercased().contains(keyword) ||
                      product.vendor.lowercased().contains(keyword) ||
                      product.tags.lowercased().contains(keyword) else { return false }
            }

            if !filter.productTypes.isEmpty {
                let type = product.productType.trimmingCharacters(in: .whitespacesAndNewlines)
                if !filter.productTypes.contains(where: { $0.caseInsensitiveCompare(type) == .orderedSame }) {
                    return false
                }
            }

            if filter.onlyAccessories {
                let isAccessory = product.productType.lowercased().contains("accessor") ||
                                  product.tags.lowercased().contains("accessor")
                if !isAccessory { return false }
            }

            if let limit = filter.maxPrice {
                let prices = product.variants.compactMap { Double($0.price) }
                if let minPrice = prices.min(), minPrice > limit { return false }
            }

            if filter.onlyInStock, !product.variants.contains(where: { $0.inventoryQuantity > 0 }) {
                return false
            }

            for (optionName, chosenValue) in filter.optionSelections {
                guard let option = product.options.first(where: { $0.name == optionName }) else { return false }
                if !option.values.contains(where: { $0.caseInsensitiveCompare(chosenValue) == .orderedSame }) { return false }
            }

            return true
        }
    }

    // MARK: - Favorites
    func isFavorite(_ product: ProductModel) -> Bool {
        dataHelper.isFavorite(product.id)
    }

    @MainActor
    func toggleFavorite(_ product: ProductModel) {
        dataHelper.toggleFavorite(product: product)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            self.favorites = self.dataHelper.fetchAllFavorites().map { $0.copy() }
        }
    }

    @MainActor
    func refreshFavorites() async {
        self.favorites = dataHelper.fetchAllFavorites().map { $0.copy() }
    }

    func removeFavorite(id: Int) {
        dataHelper.removeFavorite(id: id)
        favorites.removeAll { $0.id == id }
    }

    // MARK: - API & Local Filtering
    func loadProducts() async {
        isLoading = true
        errorMessage = nil
        do {
            let fetched = try await apiService.fetchAllProducts(limit: 250) // ðŸŸ¢ Ù‡Ù†Ø§ Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù…Ù† API
            self.allProducts = fetched
            self.products = fetched
        } catch {
            self.errorMessage = error.localizedDescription
        }
        isLoading = false
    }

    func updateProductsForCollection(_ collection: Category) {
        if collection.id == -1 || collection.title.lowercased() == "all" {
            products = allProducts
        } else {
            let normalizedTitle = collection.title.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
            products = allProducts.filter { $0.tags.lowercased().contains(normalizedTitle) }
        }
    }

    // MARK: - Categories
    func loadCategories() async {
        isLoading = true
        errorMessage = nil
        do {
            categories = try await apiService.fetchCategories()
        } catch {
            errorMessage = error.localizedDescription
        }
        isLoading = false
    }
}
