//
//  File.swift
//  ShopApp
//
//  Created by mohamed ezz on 23/10/2025.
//

import Foundation
import SwiftUI
import SwiftData


// MARK: - ProductsView (Refactored with Back Button)
struct ProductsView: View {
    @StateObject private var viewModel: ProductsViewModel
    @EnvironmentObject var navigator: AppNavigator

    // Hero overlay animation states
    @Namespace private var ns
    @State private var selectedProduct: ProductModel?
    @State private var selectedImageSrc: String?
    @State private var startFrame: CGRect = .zero
    @State private var isAnimatingOverlay = false

    private let columns = [
        GridItem(.flexible(), spacing: 16),
        GridItem(.flexible(), spacing: 16)
    ]

    init(context: ModelContext) {
        _viewModel = StateObject(wrappedValue: ProductsViewModel(context: context))
    }

    var body: some View {
        ZStack {
            mainContent
                .disabled(isAnimatingOverlay)

            overlayView
        }
        .task { await viewModel.fetchProducts() }
        .background(Color(.systemGroupedBackground))
    }

    // MARK: - Main Content
    @ViewBuilder
    private var mainContent: some View {
        VStack(spacing: 18) {
            header
            searchBar
            productGrid
        }
        .padding(.top, 6)
    }

    // MARK: - Header with Back Button
    private var header: some View {
        HStack {
            // ✅ Back Button
            Button(action: {
                navigator.goBack()
            }) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(.primary)
                    .padding(8)
                    .background(Color(.secondarySystemBackground))
                    .clipShape(Circle())
                    .shadow(color: .black.opacity(0.1), radius: 3, x: 0, y: 2)
            }

            VStack(alignment: .leading, spacing: 2) {
                Text("Products")
                    .font(.system(size: 28, weight: .bold))
                Text("\(viewModel.filteredProducts.count) items")
                    .font(.system(size: 13))
                    .foregroundColor(.secondary)
            }
            .padding(.leading, 6)

            Spacer()

            // ❤️ Favorites shortcut (optional)
            Button(action: {
                navigator.goTo(.favoritesView)
            }) {
                Image(systemName: "heart.fill")
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(.red)
                    .padding(8)
                    .background(Color(.secondarySystemBackground))
                    .clipShape(Circle())
                    .shadow(color: .black.opacity(0.1), radius: 3, x: 0, y: 2)
            }
        }
        .padding(.horizontal)
    }

    // MARK: - Search Bar
    private var searchBar: some View {
        HStack(spacing: 10) {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            TextField("Search products...", text: $viewModel.searchText)
                .textInputAutocapitalization(.never)
                .disableAutocorrection(true)
        }
        .padding(12)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
        .padding(.horizontal)
        .shadow(color: Color.black.opacity(0.03), radius: 4, x: 0, y: 2)
    }

    // MARK: - Product Grid
    @ViewBuilder
    private var productGrid: some View {
        Group {
            if viewModel.isLoading {
                VStack {
                    Spacer()
                    ProgressView()
                    Spacer()
                }
                .frame(maxWidth: .infinity)
            } else if let error = viewModel.errorMessage {
                VStack {
                    Spacer()
                    Text(error)
                        .foregroundColor(.red)
                        .multilineTextAlignment(.center)
                        .padding()
                    Spacer()
                }
            } else {
                ScrollView {
                    LazyVGrid(columns: columns, spacing: 18) {
                        ForEach(viewModel.filteredProducts) { product in
                            ProductCard(
                                product: product,
                                onTapImage: { frame, src in
                                    selectedProduct = product
                                    selectedImageSrc = src
                                    startFrame = frame
                                    isAnimatingOverlay = false
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.02) {
                                        withAnimation(.spring(response: 0.22, dampingFraction: 0.82)) {
                                            isAnimatingOverlay = true
                                        }
                                    }
                                }
                            )
                            .disabled(isAnimatingOverlay)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 20)
                }
                .refreshable { await viewModel.fetchProducts() }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    // MARK: - Overlay View (Hero Animation)
    @ViewBuilder
    private var overlayView: some View {
        if let src = selectedImageSrc,
           let product = selectedProduct,
           isAnimatingOverlay {
            GeometryReader { proxy in
                let screenW = proxy.size.width
                let targetHeight: CGFloat = 380

                CustomNetworkImage(
                    url: src,
                    width: startFrame.size.width,
                    height: startFrame.size.height,
                    cornerRadius: 12
                )
                .frame(
                    width: isAnimatingOverlay ? screenW : startFrame.size.width,
                    height: isAnimatingOverlay ? targetHeight : startFrame.size.height
                )
                .cornerRadius(isAnimatingOverlay ? 0 : 12)
                .position(
                    x: isAnimatingOverlay ? screenW / 2 : startFrame.midX,
                    y: isAnimatingOverlay ? (targetHeight / 2) + 44 : startFrame.midY
                )
                .shadow(color: .black.opacity(0.14), radius: 14, x: 0, y: 8)
                .zIndex(999)
                .onAppear {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.26) {
                        navigator.goTo(.productDetails(product))
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.08) {
                            isAnimatingOverlay = false
                            selectedImageSrc = nil
                            selectedProduct = nil
                        }
                    }
                }
            }
            .edgesIgnoringSafeArea(.all)
            .transition(.opacity.combined(with: .scale))
        }
    }
}

// MARK: - ProductCard (Reusable Component)
private struct ProductCard: View {
    @EnvironmentObject var navigator: AppNavigator
    let product: ProductModel
    var onTapImage: (_ imageFrame: CGRect, _ imageSrc: String) -> Void

    @State private var isPressed = false
    @State private var isFavorite = false

    private var priceText: String { product.variants.first?.price ?? "-" }
    private var oldPriceText: String? {
        let old = product.variants.first?.compareAtPrice ?? ""
        return old.isEmpty ? nil : old
    }

    var body: some View {
        ZStack(alignment: .bottomTrailing) {
            VStack(spacing: 10) {
                GeometryReader { geo in
                    CustomNetworkImage(
                        url: product.image?.src,
                        width: geo.size.width,
                        height: geo.size.height,
                        cornerRadius: 12
                    )
                    .clipped()
                    .onTapGesture {
                        let frame = geo.frame(in: .global)
                        onTapImage(frame, product.image?.src ?? "")
                    }
                }
                .frame(height: 160)

                VStack(spacing: 6) {
                    Text(product.title)
                        .font(.system(size: 14, weight: .semibold))
                        .multilineTextAlignment(.center)
                        .lineLimit(2)
                        .frame(maxWidth: .infinity)
                        .foregroundColor(.primary)

                    HStack(spacing: 8) {
                        Text("$\(priceText)")
                            .font(.system(size: 14, weight: .bold))
                            .foregroundColor(.accentColor)

                        if let old = oldPriceText {
                            Text("$\(old)")
                                .font(.system(size: 12))
                                .foregroundColor(.gray)
                                .strikethrough()
                        }
                    }
                }
                .padding(.horizontal, 6)
            }
            .padding(12)
            .background(Color(.systemBackground))
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.06), radius: 8, x: 0, y: 6)
            .scaleEffect(isPressed ? 0.96 : 1)
            .animation(.spring(response: 0.22, dampingFraction: 0.8), value: isPressed)
            .simultaneousGesture(
                LongPressGesture(minimumDuration: 0.01)
                    .onChanged { _ in withAnimation(.easeInOut(duration: 0.12)) { isPressed = true } }
                    .onEnded { _ in withAnimation(.easeInOut(duration: 0.18)) { isPressed = false } }
            )

            // Favorite Button
            Button(action: {
                withAnimation(.easeInOut) { isFavorite.toggle() }
            }) {
                Image(systemName: isFavorite ? "heart.fill" : "heart")
                    .font(.system(size: 18))
                    .foregroundColor(isFavorite ? .red : .gray)
                    .padding(8)
                    .background(Color.white.opacity(0.95))
                    .clipShape(Circle())
                    .shadow(color: .black.opacity(0.08), radius: 4, x: 0, y: 3)
            }
            .padding(10)
        }
        .onTapGesture {
            withAnimation(.spring(response: 0.2, dampingFraction: 0.8)) {
                isPressed = true
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.18) {
                isPressed = false
                navigator.goTo(.productDetails(product))
            }
        }
    }
}
